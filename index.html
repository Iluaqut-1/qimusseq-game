<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>Dogsled Run</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            touch-action: none;
            /* Safe area insets for iOS notches */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
        #gameCanvas {
            display: block;
            background: #87ceeb;
            max-width: 100%;
            max-height: 100vh;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            touch-action: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        // ===== CONFIGURATION =====
        const CONFIG = {
            // Display
            GAME_WIDTH: 800,
            GAME_HEIGHT: 450,
            LANE_COUNT: 3,

            // Debug
            SHOW_DEBUG: false,

            // Player
            PLAYER_X: 150,
            PLAYER_WIDTH: 120,
            PLAYER_HEIGHT: 60,
            LANE_TRANSITION_SPEED: 8,

            // Difficulty
            BASE_SPEED: 200,
            SPEED_GROWTH: 2,              // Speed increase per point
            SPEED_GROWTH_TYPE: 'linear',  // 'linear' or 'sqrt'

            // Spawning
            BASE_SPAWN_INTERVAL: 2.0,     // Seconds between spawns
            MIN_SPAWN_INTERVAL: 0.8,      // Minimum spawn interval
            SPAWN_SPEED_UP: 0.01,         // How much faster spawns get per point

            // Spawn probabilities (must sum to 1.0)
            PROB_FOX: 0.15,               // Arctic fox (+2 points, rare)
            PROB_SEAL: 0.20,              // Seal (+1 point)
            PROB_BEAR: 0.20,              // Polar bear (obstacle)
            PROB_ICEBERG: 0.20,           // Iceberg (obstacle)
            PROB_OPENING: 0.25,           // Ice opening (obstacle)

            // Collectibles
            SEAL_POINTS: 1,
            FOX_POINTS: 2,

            // Invincibility
            INVINCIBILITY_MILESTONE: 10,  // Points needed for invincibility
            INVINCIBILITY_DURATION: 10,   // Seconds of invincibility

            // Input buffering
            INPUT_BUFFER_TIME: 0.1,       // 100ms buffer window

            // Performance
            MAX_DELTA_TIME: 0.05,         // 50ms max frame time

            // Object pooling
            POOL_SIZE: 20,                // Pre-allocated objects

            // First-run tutorial
            SHOW_HINTS: true,
            HINT_DURATION: 5.0            // Seconds to show hints
        };

        const GAME_WIDTH = CONFIG.GAME_WIDTH;
        const GAME_HEIGHT = CONFIG.GAME_HEIGHT;
        const LANE_COUNT = CONFIG.LANE_COUNT;
        const LANE_HEIGHT = GAME_HEIGHT / LANE_COUNT;

        // ===== GLOBAL STATE =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;

        let gameState = {
            score: 0,
            bestScore: parseInt(localStorage.getItem('dogsledBestScore') || '0'),
            gameSpeed: CONFIG.BASE_SPEED,
            hasStarted: false,
            isGameOver: false,
            isInvincible: false,
            invincibleTimer: 0,
            lastInvincibleMilestone: 0,
            spawnTimer: 0,
            animTime: 0,
            elapsedTime: 0,
            isPaused: false,

            // Input buffering
            pendingInput: null,       // 'up' or 'down'
            inputBufferTimer: 0,

            // Tutorial state
            hasMovedUp: false,
            hasMovedDown: false,
            tutorialTimer: 0
        };

        let player = {
            lane: 1,
            x: CONFIG.PLAYER_X,
            width: CONFIG.PLAYER_WIDTH,
            height: CONFIG.PLAYER_HEIGHT,
            targetLane: 1,
            laneTransitionSpeed: CONFIG.LANE_TRANSITION_SPEED,
            isTransitioning: false
        };

        let obstacles = [];
        let collectibles = [];
        let lastTime = 0;

        // ===== OBJECT POOLING =====
        let obstaclePool = [];
        let collectiblePool = [];

        function initPools() {
            obstaclePool = [];
            collectiblePool = [];
            for (let i = 0; i < CONFIG.POOL_SIZE; i++) {
                obstaclePool.push({ active: false, type: '', lane: 0, x: 0, width: 0, height: 0 });
                collectiblePool.push({ active: false, type: '', lane: 0, x: 0, width: 0, height: 0 });
            }
        }

        function getFromPool(pool, type, lane, x, width, height) {
            for (let obj of pool) {
                if (!obj.active) {
                    obj.active = true;
                    obj.type = type;
                    obj.lane = lane;
                    obj.x = x;
                    obj.width = width;
                    obj.height = height;
                    return obj;
                }
            }
            // Pool exhausted, create new object
            const newObj = { active: true, type, lane, x, width, height };
            pool.push(newObj);
            return newObj;
        }

        function returnToPool(obj) {
            obj.active = false;
        }

        // ===== CANVAS SETUP WITH RESPONSIVE SCALING =====
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const aspectRatio = GAME_WIDTH / GAME_HEIGHT;

            let canvasWidth = window.innerWidth;
            let canvasHeight = window.innerHeight;

            // Maintain aspect ratio
            if (canvasWidth / canvasHeight > aspectRatio) {
                canvasWidth = canvasHeight * aspectRatio;
            } else {
                canvasHeight = canvasWidth / aspectRatio;
            }

            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = canvasHeight + 'px';

            canvas.width = GAME_WIDTH * dpr;
            canvas.height = GAME_HEIGHT * dpr;

            ctx.scale(dpr, dpr);
            scale = canvasWidth / GAME_WIDTH;

            offsetX = (window.innerWidth - canvasWidth) / 2;
            offsetY = (window.innerHeight - canvasHeight) / 2;
        }

        // ===== INPUT HANDLERS =====
        window.addEventListener('resize', resizeCanvas);

        // Auto-pause on tab change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                gameState.isPaused = true;
            } else {
                gameState.isPaused = false;
                // Reset lastTime to avoid huge delta on resume
                lastTime = performance.now();
            }
        });

        // Helper function to handle input with buffering
        function handleInput(direction) {
            if (gameState.isGameOver || !gameState.hasStarted) return;

            // Track tutorial progress
            if (direction === 'up') gameState.hasMovedUp = true;
            if (direction === 'down') gameState.hasMovedDown = true;

            // Try immediate movement
            if (!player.isTransitioning) {
                if (direction === 'up') {
                    player.targetLane = Math.max(0, player.targetLane - 1);
                } else if (direction === 'down') {
                    player.targetLane = Math.min(LANE_COUNT - 1, player.targetLane + 1);
                }
            } else {
                // Buffer the input for later
                gameState.pendingInput = direction;
                gameState.inputBufferTimer = CONFIG.INPUT_BUFFER_TIME;
            }
        }

        // Keyboard controls for desktop
        document.addEventListener('keydown', (e) => {
            if (gameState.isGameOver) {
                if (e.code === 'Space') {
                    resetGame();
                }
                return;
            }

            if (!gameState.hasStarted) {
                gameState.hasStarted = true;
                return;
            }

            if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                handleInput('up');
            } else if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                handleInput('down');
            }
        });

        // Touch controls for mobile - prevent scroll/zoom
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();

            if (gameState.isGameOver) {
                resetGame();
                return;
            }

            if (!gameState.hasStarted) {
                gameState.hasStarted = true;
                return;
            }

            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const y = (touch.clientY - rect.top) / scale;

            // Tap upper half = move up, lower half = move down
            if (y < GAME_HEIGHT / 2) {
                handleInput('up');
            } else {
                handleInput('down');
            }
        }, { passive: false });

        // Click controls for desktop
        canvas.addEventListener('click', (e) => {
            if (gameState.isGameOver) {
                resetGame();
                return;
            }

            if (!gameState.hasStarted) {
                gameState.hasStarted = true;
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const y = (e.clientY - rect.top) / scale;

            if (y < GAME_HEIGHT / 2) {
                handleInput('up');
            } else {
                handleInput('down');
            }
        });

        // ===== GAME LOGIC =====
        function resetGame() {
            gameState.score = 0;
            gameState.gameSpeed = CONFIG.BASE_SPEED;
            gameState.isGameOver = false;
            gameState.hasStarted = false;
            gameState.isInvincible = false;
            gameState.invincibleTimer = 0;
            gameState.lastInvincibleMilestone = 0;
            gameState.spawnTimer = 0;
            gameState.animTime = 0;
            gameState.elapsedTime = 0;
            gameState.pendingInput = null;
            gameState.inputBufferTimer = 0;
            gameState.hasMovedUp = false;
            gameState.hasMovedDown = false;
            gameState.tutorialTimer = 0;

            player.lane = 1;
            player.targetLane = 1;
            player.isTransitioning = false;

            // Return all objects to pool
            obstacles.forEach(returnToPool);
            collectibles.forEach(returnToPool);
            obstacles = [];
            collectibles = [];
        }

        function spawnObject() {
            const lane = Math.floor(Math.random() * LANE_COUNT);
            const type = Math.random();

            // Use CONFIG probabilities
            let cumulative = 0;

            cumulative += CONFIG.PROB_FOX;
            if (type < cumulative) {
                // Arctic fox (rare, +2 points)
                const obj = getFromPool(collectiblePool, 'fox', lane, GAME_WIDTH, 40, 30);
                collectibles.push(obj);
                return;
            }

            cumulative += CONFIG.PROB_SEAL;
            if (type < cumulative) {
                // Seal (+1 point)
                const obj = getFromPool(collectiblePool, 'seal', lane, GAME_WIDTH, 45, 35);
                collectibles.push(obj);
                return;
            }

            cumulative += CONFIG.PROB_BEAR;
            if (type < cumulative) {
                // Polar bear (obstacle)
                const obj = getFromPool(obstaclePool, 'bear', lane, GAME_WIDTH, 70, 60);
                obstacles.push(obj);
                return;
            }

            cumulative += CONFIG.PROB_ICEBERG;
            if (type < cumulative) {
                // Iceberg (obstacle)
                const obj = getFromPool(obstaclePool, 'iceberg', lane, GAME_WIDTH, 60, 80);
                obstacles.push(obj);
                return;
            }

            // Sea-ice opening (obstacle)
            const obj = getFromPool(obstaclePool, 'opening', lane, GAME_WIDTH, 80, LANE_HEIGHT);
            obstacles.push(obj);
        }

        function checkCollision(obj1, obj2) {
            return obj1.lane === obj2.lane &&
                   player.x < obj2.x + obj2.width &&
                   player.x + player.width > obj2.x;
        }

        function updatePlayer(dt) {
            // Smooth lane transition
            if (player.lane !== player.targetLane) {
                player.isTransitioning = true;
                const direction = player.targetLane > player.lane ? 1 : -1;
                player.lane += direction * player.laneTransitionSpeed * dt;

                if (direction > 0 && player.lane >= player.targetLane) {
                    player.lane = player.targetLane;
                    player.isTransitioning = false;
                } else if (direction < 0 && player.lane <= player.targetLane) {
                    player.lane = player.targetLane;
                    player.isTransitioning = false;
                }
            } else {
                player.isTransitioning = false;
            }

            // Consume buffered input when transition completes
            if (!player.isTransitioning && gameState.pendingInput && gameState.inputBufferTimer > 0) {
                if (gameState.pendingInput === 'up') {
                    player.targetLane = Math.max(0, player.targetLane - 1);
                } else if (gameState.pendingInput === 'down') {
                    player.targetLane = Math.min(LANE_COUNT - 1, player.targetLane + 1);
                }
                gameState.pendingInput = null;
                gameState.inputBufferTimer = 0;
            }

            // Decay input buffer timer
            if (gameState.inputBufferTimer > 0) {
                gameState.inputBufferTimer -= dt;
                if (gameState.inputBufferTimer <= 0) {
                    gameState.pendingInput = null;
                }
            }
        }

        function updateDifficulty(dt) {
            gameState.elapsedTime += dt;

            // Difficulty scaling
            if (CONFIG.SPEED_GROWTH_TYPE === 'sqrt') {
                gameState.gameSpeed = CONFIG.BASE_SPEED + CONFIG.SPEED_GROWTH * Math.sqrt(gameState.score);
            } else {
                gameState.gameSpeed = CONFIG.BASE_SPEED + CONFIG.SPEED_GROWTH * gameState.score;
            }
        }

        function updateInvincibility(dt) {
            // Update invincibility timer
            if (gameState.isInvincible) {
                gameState.invincibleTimer -= dt;
                if (gameState.invincibleTimer <= 0) {
                    gameState.isInvincible = false;
                    gameState.invincibleTimer = 0;
                }
            }

            // Check for invincibility milestone
            const currentMilestone = Math.floor(gameState.score / CONFIG.INVINCIBILITY_MILESTONE) * CONFIG.INVINCIBILITY_MILESTONE;
            if (currentMilestone > gameState.lastInvincibleMilestone && currentMilestone > 0) {
                gameState.isInvincible = true;
                gameState.invincibleTimer = CONFIG.INVINCIBILITY_DURATION;
                gameState.lastInvincibleMilestone = currentMilestone;
            }
        }

        function updateSpawning(dt) {
            gameState.spawnTimer -= dt;
            if (gameState.spawnTimer <= 0) {
                spawnObject();
                gameState.spawnTimer = CONFIG.BASE_SPAWN_INTERVAL - (gameState.score * CONFIG.SPAWN_SPEED_UP);
                gameState.spawnTimer = Math.max(CONFIG.MIN_SPAWN_INTERVAL, gameState.spawnTimer);
            }
        }

        function updateObstacles(dt) {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.x -= gameState.gameSpeed * dt;

                // Remove off-screen obstacles
                if (obs.x + obs.width < 0) {
                    returnToPool(obs);
                    obstacles.splice(i, 1);
                    continue;
                }

                // Check collision
                if (checkCollision(player, obs) && !gameState.isInvincible) {
                    gameState.isGameOver = true;
                    if (gameState.score > gameState.bestScore) {
                        gameState.bestScore = gameState.score;
                        localStorage.setItem('dogsledBestScore', gameState.bestScore);
                    }
                }
            }
        }

        function updateCollectibles(dt) {
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const col = collectibles[i];
                col.x -= gameState.gameSpeed * dt;

                // Remove off-screen collectibles
                if (col.x + col.width < 0) {
                    returnToPool(col);
                    collectibles.splice(i, 1);
                    continue;
                }

                // Check collection
                if (checkCollision(player, col)) {
                    if (col.type === 'seal') {
                        gameState.score += CONFIG.SEAL_POINTS;
                    } else if (col.type === 'fox') {
                        gameState.score += CONFIG.FOX_POINTS;
                    }
                    returnToPool(col);
                    collectibles.splice(i, 1);
                }
            }
        }

        function update(dt) {
            if (!gameState.hasStarted || gameState.isGameOver || gameState.isPaused) return;

            gameState.animTime += dt;
            gameState.tutorialTimer += dt;

            updatePlayer(dt);
            updateDifficulty(dt);
            updateInvincibility(dt);
            updateSpawning(dt);
            updateObstacles(dt);
            updateCollectibles(dt);
        }

        // ===== DRAWING FUNCTIONS =====
        function drawBackground() {
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
            gradient.addColorStop(0, '#2c5f8d');
            gradient.addColorStop(0.6, '#87ceeb');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Ground (sea ice)
            ctx.fillStyle = '#e0f2f7';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Ice texture lines (animated)
            ctx.strokeStyle = '#c8e6f0';
            ctx.lineWidth = 2;
            const offset = (gameState.animTime * 100) % 100;
            for (let x = -100 + offset; x < GAME_WIDTH; x += 100) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x + 50, GAME_HEIGHT);
                ctx.stroke();
            }

            // Lane dividers
            ctx.strokeStyle = 'rgba(150, 200, 220, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 1; i < LANE_COUNT; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * LANE_HEIGHT);
                ctx.lineTo(GAME_WIDTH, i * LANE_HEIGHT);
                ctx.stroke();
            }
        }

        // Draw single dog with animation
        function drawDog(x, y, size = 1, bobOffset = 0) {
            ctx.save();
            ctx.translate(x, y + bobOffset);

            // Body
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.ellipse(0, 0, 20 * size, 12 * size, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(18 * size, -2 * size, 10 * size, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.moveTo(14 * size, -10 * size);
            ctx.lineTo(12 * size, -16 * size);
            ctx.lineTo(18 * size, -12 * size);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(22 * size, -10 * size);
            ctx.lineTo(24 * size, -16 * size);
            ctx.lineTo(18 * size, -12 * size);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(25 * size, -2 * size, 3 * size, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw complete dogsled team with animations
        function drawDogsled() {
            const centerY = player.lane * LANE_HEIGHT + LANE_HEIGHT / 2;
            const bobAmount = Math.sin(gameState.animTime * 8) * 3; // Running bobbing animation
            const ropeBob = Math.sin(gameState.animTime * 6) * 2;   // Rope wobble

            // Draw invincibility aura
            if (gameState.isInvincible) {
                ctx.strokeStyle = '#ffeb3b';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffeb3b';
                ctx.strokeRect(player.x - 10, centerY - player.height/2 - 10,
                              player.width + 20, player.height + 20);
                ctx.shadowBlur = 0;
            }

            // Dogs positions
            const dogs = [
                { x: player.x + 90, y: centerY, size: 1 },      // Lead dog
                { x: player.x + 60, y: centerY, size: 0.9 },    // Dog 2
                { x: player.x + 35, y: centerY, size: 0.85 },   // Dog 3
            ];

            // Draw ropes connecting dogs and sled
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            for (let i = 0; i < dogs.length; i++) {
                ctx.beginPath();
                if (i === dogs.length - 1) {
                    ctx.moveTo(dogs[i].x - 15, dogs[i].y + ropeBob);
                    ctx.lineTo(player.x + 15, centerY);
                } else {
                    ctx.moveTo(dogs[i].x - 15, dogs[i].y + ropeBob);
                    ctx.lineTo(dogs[i + 1].x + 15, dogs[i + 1].y + ropeBob);
                }
                ctx.stroke();
            }

            // Draw dogs
            dogs.forEach(dog => {
                drawDog(dog.x, dog.y, dog.size, bobAmount);
            });

            // Sled with rocking animation
            ctx.fillStyle = '#654321';
            const sledBob = Math.sin(gameState.animTime * 7) * 2;
            ctx.fillRect(player.x - 10, centerY - 8 + sledBob, 50, 16);

            // Sled runners
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(player.x - 10, centerY + 8 + sledBob);
            ctx.lineTo(player.x + 40, centerY + 8 + sledBob);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(player.x - 10, centerY - 8 + sledBob);
            ctx.lineTo(player.x + 40, centerY - 8 + sledBob);
            ctx.stroke();

            // Musher (respectful stylized representation)
            // Body (parka/coat)
            ctx.fillStyle = '#004d66';
            ctx.fillRect(player.x + 5, centerY - 28 + sledBob, 20, 20);

            // Head
            ctx.fillStyle = '#d4a574';
            ctx.beginPath();
            ctx.arc(player.x + 15, centerY - 32 + sledBob, 8, 0, Math.PI * 2);
            ctx.fill();

            // Hood
            ctx.fillStyle = '#003d52';
            ctx.beginPath();
            ctx.arc(player.x + 15, centerY - 32 + sledBob, 10, Math.PI, 0);
            ctx.fill();
        }

        // Draw polar bear with bobbing animation
        function drawPolarBear(x, y) {
            const bob = Math.sin(gameState.animTime * 3 + x) * 4;
            const headNod = Math.sin(gameState.animTime * 4) * 2;

            ctx.fillStyle = '#f0f0f0';
            // Body
            ctx.beginPath();
            ctx.ellipse(x, y + bob, 35, 25, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head with nodding animation
            ctx.beginPath();
            ctx.ellipse(x + 30, y - 5 + bob + headNod, 20, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.beginPath();
            ctx.arc(x + 22, y - 20 + bob + headNod, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 38, y - 20 + bob + headNod, 6, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(x + 42, y - 3 + bob + headNod, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw seal with bobbing and tail wiggle
        function drawSeal(x, y) {
            const bob = Math.sin(gameState.animTime * 4 + x) * 3;
            const tailWiggle = Math.sin(gameState.animTime * 6 + x) * 5;

            ctx.fillStyle = '#696969';
            // Body
            ctx.beginPath();
            ctx.ellipse(x, y + bob, 22, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.ellipse(x + 18, y + bob, 12, 11, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tail with wiggle
            ctx.beginPath();
            ctx.ellipse(x - 18 + tailWiggle, y + bob, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x + 22, y - 3 + bob, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw arctic fox with tail wag and hopping
        function drawFox(x, y) {
            const tailWag = Math.sin(gameState.animTime * 8 + x) * 8;
            const hop = Math.abs(Math.sin(gameState.animTime * 5 + x)) * 6;

            ctx.fillStyle = '#fff';
            // Body
            ctx.fillRect(x - 10, y - 8 - hop, 20, 12);

            // Head (triangular snout)
            ctx.beginPath();
            ctx.moveTo(x + 10, y - 8 - hop);
            ctx.lineTo(x + 20, y - 2 - hop);
            ctx.lineTo(x + 10, y + 4 - hop);
            ctx.fill();

            // Ears
            ctx.beginPath();
            ctx.moveTo(x + 12, y - 8 - hop);
            ctx.lineTo(x + 14, y - 14 - hop);
            ctx.lineTo(x + 16, y - 8 - hop);
            ctx.fill();

            // Tail with wag animation
            ctx.beginPath();
            ctx.ellipse(x - 18 + tailWag, y - 2 - hop, 10, 6, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(x + 20, y - 2 - hop, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw iceberg with subtle drift
        function drawIceberg(x, y) {
            const drift = Math.sin(gameState.animTime * 2 + x * 0.1) * 2;

            ctx.fillStyle = '#e6f9ff';
            ctx.strokeStyle = '#b3e5fc';
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(x + drift, y + 20);
            ctx.lineTo(x + 15 + drift, y - 30);
            ctx.lineTo(x + 25 + drift, y - 40);
            ctx.lineTo(x + 35 + drift, y - 35);
            ctx.lineTo(x + 45 + drift, y - 20);
            ctx.lineTo(x + 60 + drift, y + 20);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        // Draw sea-ice opening with wave effect
        function drawOpening(x, y, width) {
            const wave = Math.sin(gameState.animTime * 4 + x * 0.1) * 3;

            // Dark water
            ctx.fillStyle = '#1e3a5f';
            ctx.fillRect(x, y - LANE_HEIGHT / 2, width, LANE_HEIGHT);

            // Wave lines
            ctx.strokeStyle = '#2c5f8d';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x, y - 10 + i * 10 + wave);
                ctx.lineTo(x + width, y - 10 + i * 10 + wave);
                ctx.stroke();
            }

            // Ice edges
            ctx.fillStyle = '#b3d9e6';
            ctx.fillRect(x, y - LANE_HEIGHT / 2, 5, LANE_HEIGHT);
            ctx.fillRect(x + width - 5, y - LANE_HEIGHT / 2, 5, LANE_HEIGHT);
        }

        function drawHUD() {
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Arial';
            ctx.fillText(`Score: ${gameState.score}`, 20, 35);
            ctx.fillText(`Best: ${gameState.bestScore}`, 20, 65);

            if (gameState.isInvincible) {
                ctx.fillStyle = '#ffeb3b';
                ctx.font = 'bold 28px Arial';
                ctx.fillText(`INVINCIBLE: ${gameState.invincibleTimer.toFixed(1)}s`,
                            GAME_WIDTH / 2 - 100, 40);
            }

            // Debug mode
            if (CONFIG.SHOW_DEBUG) {
                ctx.fillStyle = '#0f0';
                ctx.font = '14px Arial';
                ctx.fillText(`Speed: ${gameState.gameSpeed.toFixed(0)}`, GAME_WIDTH - 150, 30);
                ctx.fillText(`Spawn: ${gameState.spawnTimer.toFixed(2)}s`, GAME_WIDTH - 150, 50);
                ctx.fillText(`FPS: ${(1000 / (performance.now() - lastTime)).toFixed(0)}`, GAME_WIDTH - 150, 70);
                ctx.fillText(`Obstacles: ${obstacles.length}`, GAME_WIDTH - 150, 90);
                ctx.fillText(`Collectibles: ${collectibles.length}`, GAME_WIDTH - 150, 110);
                ctx.fillText(`Pool size: ${obstaclePool.length + collectiblePool.length}`, GAME_WIDTH - 150, 130);

                // Draw bounding boxes for player
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                const playerY = player.lane * LANE_HEIGHT + LANE_HEIGHT / 2;
                ctx.strokeRect(player.x, playerY - player.height/2, player.width, player.height);

                // Draw bounding boxes for obstacles
                ctx.strokeStyle = '#f00';
                obstacles.forEach(obs => {
                    const centerY = obs.lane * LANE_HEIGHT + LANE_HEIGHT / 2;
                    ctx.strokeRect(obs.x, centerY - obs.height/2, obs.width, obs.height);
                });

                // Draw bounding boxes for collectibles
                ctx.strokeStyle = '#0ff';
                collectibles.forEach(col => {
                    const centerY = col.lane * LANE_HEIGHT + LANE_HEIGHT / 2;
                    ctx.strokeRect(col.x, centerY - col.height/2, col.width, col.height);
                });
            }

            // First-run hints
            if (CONFIG.SHOW_HINTS && gameState.hasStarted && !gameState.isGameOver && gameState.tutorialTimer < CONFIG.HINT_DURATION) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, 1 - (gameState.tutorialTimer / CONFIG.HINT_DURATION));
                ctx.fillStyle = '#fff';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';

                if (!gameState.hasMovedUp) {
                    ctx.fillText('⬆ Tap top half to move up ⬆', GAME_WIDTH / 2, GAME_HEIGHT / 4);
                }

                if (!gameState.hasMovedDown) {
                    ctx.fillText('⬇ Tap bottom half to move down ⬇', GAME_WIDTH / 2, GAME_HEIGHT * 3 / 4);
                }

                ctx.textAlign = 'left';
                ctx.restore();
            }
        }

        function drawStartScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Dogsled Run', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 40);

            ctx.font = '24px Arial';
            ctx.fillText('Tap or Press Any Key to Start', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 20);

            ctx.font = '18px Arial';
            ctx.fillText('Avoid obstacles • Collect animals', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 60);
            ctx.fillText('Invincibility every 10 points', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 90);

            ctx.textAlign = 'left';
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 60);

            ctx.font = '32px Arial';
            ctx.fillText(`Score: ${gameState.score}`, GAME_WIDTH / 2, GAME_HEIGHT / 2);
            ctx.fillText(`Best: ${gameState.bestScore}`, GAME_WIDTH / 2, GAME_HEIGHT / 2 + 40);

            ctx.font = '24px Arial';
            ctx.fillText('Tap or Press Space to Restart', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 100);

            ctx.textAlign = 'left';
        }

        function draw() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            drawBackground();

            // Draw obstacles
            obstacles.forEach(obs => {
                const centerY = obs.lane * LANE_HEIGHT + LANE_HEIGHT / 2;
                if (obs.type === 'bear') {
                    drawPolarBear(obs.x, centerY);
                } else if (obs.type === 'iceberg') {
                    drawIceberg(obs.x, centerY);
                } else if (obs.type === 'opening') {
                    drawOpening(obs.x, centerY, obs.width);
                }
            });

            // Draw collectibles
            collectibles.forEach(col => {
                const centerY = col.lane * LANE_HEIGHT + LANE_HEIGHT / 2;
                if (col.type === 'seal') {
                    drawSeal(col.x, centerY);
                } else if (col.type === 'fox') {
                    drawFox(col.x, centerY);
                }
            });

            // Draw player dogsled team
            drawDogsled();

            // Draw HUD
            drawHUD();

            // Draw overlays
            if (!gameState.hasStarted) {
                drawStartScreen();
            } else if (gameState.isGameOver) {
                drawGameOver();
            }
        }

        // ===== GAME LOOP =====
        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, CONFIG.MAX_DELTA_TIME);
            lastTime = timestamp;

            update(dt);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // ===== INITIALIZATION =====
        initPools();
        resizeCanvas();
        resetGame();
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
